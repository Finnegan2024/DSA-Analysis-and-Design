# DSA-Analysis-and-Design

#What was the problem you were solving in the projects for this course?
I was working on a project to help the computer science department from ABC University access course information for students. Specifically, in the first project I utilized non-coding methods–pseudocode and flowcharts–to analysis and design various data structures to hold course objects and their attributes. The second project required a full implementation of the psuedocode controlled by a main menu that would load all course data into a binary search tree from a given csv file, print out all courses in alphanumeric order from the BST, and search and print specific courses using their course name as a search id.

#How did you approach the problem? Consider why data structures are important to understand.
I started by attaining an understanding of data structures and how each data structure can influence a program's runtime and memory analysis. After determining how to implement each data structure and comparing them, I decided to use the binary search tree to handle quick load, print, and search times of courses for the ABCU application. By using a combination of non-coding techniques and implementing modular code, I was able to deconstruct the application into smaller manageable componenets which made implementation simpler and efficient.

#How did you overcome any roadblocks you encountered while going through the activities or project?
I first reviewed any resources we were given in each module and reviewed past modules to find additional information regarding my issues. Once I determined that the resources were not providing me with sufficient answers, I searched online for similar problems to find possible solutions or ideas for solutions. There are all sorts of communities online which have been extremely helpful in identifying my issues and resolving them.

#How has your work on this project expanded your approach to designing software and developing programs?
I've learned just how beneficial non-coding techniques are in analysing and designing applications. Designing modular applications becomes extremely important with larger applications, and through a deliberate and methodical planning process, implementation became simpler, more efficient, and manageable.

#How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
As I've mentioned, using pseudocode and flow harts have helped tremendously in creating modular applications. As each section of code becomes more modular, I can then begin to change code within the applicaiton that becomes maintainable–I know where to find the issues and resolve them quicikly. The application also becomes more readable–each section of the code is broken down into its respective component, allowing programmers to read and follow along smoothly. Finally, the application also becomes more adaptable as each modularized section can be fixed and altered without having extraneous negative effects outside of the modularized section.
